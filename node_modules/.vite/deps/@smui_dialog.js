import {
  AnimationFrame
} from "./chunk-4LU6W7XY.js";
import {
  classAdderBuilder
} from "./chunk-O74RPVUT.js";
import {
  MDCRipple
} from "./chunk-ZZXAOYQJ.js";
import {
  FocusTrap,
  closest,
  focus_trap_exports,
  matches,
  ponyfill_exports
} from "./chunk-LT7LFURX.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __values
} from "./chunk-2FLFGTFT.js";
import "./chunk-PYKRMECV.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-MPIJALNF.js";
import {
  writable
} from "./chunk-ADM3CLVU.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  globals,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-3PEI35UK.js";
import {
  __export
} from "./chunk-JC4IRQUL.js";

// node_modules/@material/dialog/util.js
var util_exports = {};
__export(util_exports, {
  areTopsMisaligned: () => areTopsMisaligned,
  createFocusTrapInstance: () => createFocusTrapInstance,
  isScrollAtBottom: () => isScrollAtBottom,
  isScrollAtTop: () => isScrollAtTop,
  isScrollable: () => isScrollable
});
function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
  return focusTrapFactory(surfaceEl, { initialFocusEl });
}
function isScrollable(el) {
  return el ? el.scrollHeight > el.offsetHeight : false;
}
function isScrollAtTop(el) {
  return el ? el.scrollTop === 0 : false;
}
function isScrollAtBottom(el) {
  return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;
}
function areTopsMisaligned(els) {
  var tops = /* @__PURE__ */ new Set();
  [].forEach.call(els, function(el) {
    return tops.add(el.offsetTop);
  });
  return tops.size > 1;
}

// node_modules/@material/dialog/constants.js
var cssClasses = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  // Class for showing a scroll divider on full-screen dialog header element.
  // Should only be displayed on scrollable content, when the dialog content is
  // scrolled "underneath" the header.
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  // Class for showing a scroll divider on a full-screen dialog footer element.
  // Should only be displayed on scrolalble content, when the dialog content is
  // obscured "underneath" the footer.
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  // The "surface scrim" is a scrim covering only the surface of a dialog. This
  // is used in situations where a confirmation dialog is shown over an already
  // opened full-screen dialog. On larger screen-sizes, the full-screen dialog
  // is sized as a modal and so in these situations we display a "surface scrim"
  // to prevent a "double scrim" (where the scrim from the secondary
  // confirmation dialog would overlap with the scrim from the full-screen
  // dialog).
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  // "Showing" animating class for the surface-scrim.
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  // "Hiding" animating class for the surface-scrim.
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  // Class to hide a dialog's scrim (used in conjunction with a surface-scrim).
  // Note that we only hide the original scrim rather than removing it entirely
  // to prevent interactions with the content behind this scrim, and to capture
  // scrim clicks.
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
var strings = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
var numbers = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};

// node_modules/@material/dialog/foundation.js
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_SCROLL_POS"] = "poll_scroll_position";
  AnimationKeys2["POLL_LAYOUT_CHANGE"] = "poll_layout_change";
})(AnimationKeys || (AnimationKeys = {}));
var MDCDialogFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCDialogFoundation2, _super);
    function MDCDialogFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation2.defaultAdapter), adapter)) || this;
      _this.dialogOpen = false;
      _this.isFullscreen = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      _this.escapeKeyAction = strings.CLOSE_ACTION;
      _this.scrimClickAction = strings.CLOSE_ACTION;
      _this.autoStackButtons = true;
      _this.areButtonsStacked = false;
      _this.suppressDefaultPressSelector = strings.SUPPRESS_DEFAULT_PRESS_SELECTOR;
      _this.animFrame = new AnimationFrame();
      _this.contentScrollHandler = function() {
        _this.handleScrollEvent();
      };
      _this.windowResizeHandler = function() {
        _this.layout();
      };
      _this.windowOrientationChangeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCDialogFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addBodyClass: function() {
            return void 0;
          },
          addClass: function() {
            return void 0;
          },
          areButtonsStacked: function() {
            return false;
          },
          clickDefaultButton: function() {
            return void 0;
          },
          eventTargetMatches: function() {
            return false;
          },
          getActionFromEvent: function() {
            return "";
          },
          getInitialFocusEl: function() {
            return null;
          },
          hasClass: function() {
            return false;
          },
          isContentScrollable: function() {
            return false;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          releaseFocus: function() {
            return void 0;
          },
          removeBodyClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          reverseButtons: function() {
            return void 0;
          },
          trapFocus: function() {
            return void 0;
          },
          registerContentEventHandler: function() {
            return void 0;
          },
          deregisterContentEventHandler: function() {
            return void 0;
          },
          isScrollableContentAtTop: function() {
            return false;
          },
          isScrollableContentAtBottom: function() {
            return false;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCDialogFoundation2.prototype.init = function() {
      if (this.adapter.hasClass(cssClasses.STACKED)) {
        this.setAutoStackButtons(false);
      }
      this.isFullscreen = this.adapter.hasClass(cssClasses.FULLSCREEN);
    };
    MDCDialogFoundation2.prototype.destroy = function() {
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
        this.handleAnimationTimerEnd();
      }
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.animFrame.cancelAll();
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    };
    MDCDialogFoundation2.prototype.open = function(dialogOptions) {
      var _this = this;
      this.dialogOpen = true;
      this.adapter.notifyOpening();
      this.adapter.addClass(cssClasses.OPENING);
      if (this.isFullscreen) {
        this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
      }
      if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
        this.adapter.addClass(cssClasses.SCRIM_HIDDEN);
      }
      this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.registerWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses.OPEN);
        _this.adapter.addBodyClass(cssClasses.SCROLL_LOCK);
        _this.layout();
        _this.animationTimer = setTimeout(function() {
          _this.handleAnimationTimerEnd();
          _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
          _this.adapter.notifyOpened();
        }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCDialogFoundation2.prototype.close = function(action) {
      var _this = this;
      if (action === void 0) {
        action = "";
      }
      if (!this.dialogOpen) {
        return;
      }
      this.dialogOpen = false;
      this.adapter.notifyClosing(action);
      this.adapter.addClass(cssClasses.CLOSING);
      this.adapter.removeClass(cssClasses.OPEN);
      this.adapter.removeBodyClass(cssClasses.SCROLL_LOCK);
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.adapter.releaseFocus();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(action);
      }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
    };
    MDCDialogFoundation2.prototype.showSurfaceScrim = function() {
      var _this = this;
      this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWING);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWN);
      });
    };
    MDCDialogFoundation2.prototype.hideSurfaceScrim = function() {
      this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWN);
      this.adapter.addClass(cssClasses.SURFACE_SCRIM_HIDING);
    };
    MDCDialogFoundation2.prototype.handleSurfaceScrimTransitionEnd = function() {
      this.adapter.removeClass(cssClasses.SURFACE_SCRIM_HIDING);
      this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWING);
    };
    MDCDialogFoundation2.prototype.isOpen = function() {
      return this.dialogOpen;
    };
    MDCDialogFoundation2.prototype.getEscapeKeyAction = function() {
      return this.escapeKeyAction;
    };
    MDCDialogFoundation2.prototype.setEscapeKeyAction = function(action) {
      this.escapeKeyAction = action;
    };
    MDCDialogFoundation2.prototype.getScrimClickAction = function() {
      return this.scrimClickAction;
    };
    MDCDialogFoundation2.prototype.setScrimClickAction = function(action) {
      this.scrimClickAction = action;
    };
    MDCDialogFoundation2.prototype.getAutoStackButtons = function() {
      return this.autoStackButtons;
    };
    MDCDialogFoundation2.prototype.setAutoStackButtons = function(autoStack) {
      this.autoStackButtons = autoStack;
    };
    MDCDialogFoundation2.prototype.getSuppressDefaultPressSelector = function() {
      return this.suppressDefaultPressSelector;
    };
    MDCDialogFoundation2.prototype.setSuppressDefaultPressSelector = function(selector) {
      this.suppressDefaultPressSelector = selector;
    };
    MDCDialogFoundation2.prototype.layout = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function() {
        _this.layoutInternal();
      });
    };
    MDCDialogFoundation2.prototype.handleClick = function(evt) {
      var isScrim = this.adapter.eventTargetMatches(evt.target, strings.SCRIM_SELECTOR);
      if (isScrim && this.scrimClickAction !== "") {
        this.close(this.scrimClickAction);
      } else {
        var action = this.adapter.getActionFromEvent(evt);
        if (action) {
          this.close(action);
        }
      }
    };
    MDCDialogFoundation2.prototype.handleKeydown = function(evt) {
      var isEnter = evt.key === "Enter" || evt.keyCode === 13;
      if (!isEnter) {
        return;
      }
      var action = this.adapter.getActionFromEvent(evt);
      if (action) {
        return;
      }
      var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
      var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
      if (isEnter && isDefault) {
        this.adapter.clickDefaultButton();
      }
    };
    MDCDialogFoundation2.prototype.handleDocumentKeydown = function(evt) {
      var isEscape = evt.key === "Escape" || evt.keyCode === 27;
      if (isEscape && this.escapeKeyAction !== "") {
        this.close(this.escapeKeyAction);
      }
    };
    MDCDialogFoundation2.prototype.handleScrollEvent = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function() {
        _this.toggleScrollDividerHeader();
        _this.toggleScrollDividerFooter();
      });
    };
    MDCDialogFoundation2.prototype.layoutInternal = function() {
      if (this.autoStackButtons) {
        this.detectStackedButtons();
      }
      this.toggleScrollableClasses();
    };
    MDCDialogFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(cssClasses.OPENING);
      this.adapter.removeClass(cssClasses.CLOSING);
    };
    MDCDialogFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    MDCDialogFoundation2.prototype.detectStackedButtons = function() {
      this.adapter.removeClass(cssClasses.STACKED);
      var areButtonsStacked = this.adapter.areButtonsStacked();
      if (areButtonsStacked) {
        this.adapter.addClass(cssClasses.STACKED);
      }
      if (areButtonsStacked !== this.areButtonsStacked) {
        this.adapter.reverseButtons();
        this.areButtonsStacked = areButtonsStacked;
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollableClasses = function() {
      this.adapter.removeClass(cssClasses.SCROLLABLE);
      if (this.adapter.isContentScrollable()) {
        this.adapter.addClass(cssClasses.SCROLLABLE);
        if (this.isFullscreen) {
          this.toggleScrollDividerHeader();
          this.toggleScrollDividerFooter();
        }
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerHeader = function() {
      if (!this.adapter.isScrollableContentAtTop()) {
        this.adapter.addClass(cssClasses.SCROLL_DIVIDER_HEADER);
      } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_HEADER)) {
        this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_HEADER);
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerFooter = function() {
      if (!this.adapter.isScrollableContentAtBottom()) {
        this.adapter.addClass(cssClasses.SCROLL_DIVIDER_FOOTER);
      } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_FOOTER)) {
        this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_FOOTER);
      }
    };
    return MDCDialogFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/dialog/component.js
var strings2 = MDCDialogFoundation.strings;
var MDCDialog = (
  /** @class */
  function(_super) {
    __extends(MDCDialog2, _super);
    function MDCDialog2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCDialog2.prototype, "isOpen", {
      get: function() {
        return this.foundation.isOpen();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "escapeKeyAction", {
      get: function() {
        return this.foundation.getEscapeKeyAction();
      },
      set: function(action) {
        this.foundation.setEscapeKeyAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "scrimClickAction", {
      get: function() {
        return this.foundation.getScrimClickAction();
      },
      set: function(action) {
        this.foundation.setScrimClickAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "autoStackButtons", {
      get: function() {
        return this.foundation.getAutoStackButtons();
      },
      set: function(autoStack) {
        this.foundation.setAutoStackButtons(autoStack);
      },
      enumerable: false,
      configurable: true
    });
    MDCDialog2.attachTo = function(root) {
      return new MDCDialog2(root);
    };
    MDCDialog2.prototype.initialize = function(focusTrapFactory) {
      var e_1, _a;
      if (focusTrapFactory === void 0) {
        focusTrapFactory = function(el, focusOptions) {
          return new FocusTrap(el, focusOptions);
        };
      }
      var container = this.root.querySelector(strings2.CONTAINER_SELECTOR);
      if (!container) {
        throw new Error("Dialog component requires a " + strings2.CONTAINER_SELECTOR + " container element");
      }
      this.container = container;
      this.content = this.root.querySelector(strings2.CONTENT_SELECTOR);
      this.buttons = [].slice.call(this.root.querySelectorAll(strings2.BUTTON_SELECTOR));
      this.defaultButton = this.root.querySelector("[" + strings2.BUTTON_DEFAULT_ATTRIBUTE + "]");
      this.focusTrapFactory = focusTrapFactory;
      this.buttonRipples = [];
      try {
        for (var _b = __values(this.buttons), _c = _b.next(); !_c.done; _c = _b.next()) {
          var buttonEl = _c.value;
          this.buttonRipples.push(new MDCRipple(buttonEl));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCDialog2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.focusTrap = createFocusTrapInstance(this.container, this.focusTrapFactory, this.getInitialFocusEl() || void 0);
      this.handleClick = this.foundation.handleClick.bind(this.foundation);
      this.handleKeydown = this.foundation.handleKeydown.bind(this.foundation);
      this.handleDocumentKeydown = this.foundation.handleDocumentKeydown.bind(this.foundation);
      this.handleOpening = function() {
        document.addEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.handleClosing = function() {
        document.removeEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
      this.listen(strings2.OPENING_EVENT, this.handleOpening);
      this.listen(strings2.CLOSING_EVENT, this.handleClosing);
    };
    MDCDialog2.prototype.destroy = function() {
      this.unlisten("click", this.handleClick);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(strings2.OPENING_EVENT, this.handleOpening);
      this.unlisten(strings2.CLOSING_EVENT, this.handleClosing);
      this.handleClosing();
      this.buttonRipples.forEach(function(ripple) {
        ripple.destroy();
      });
      _super.prototype.destroy.call(this);
    };
    MDCDialog2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCDialog2.prototype.open = function() {
      this.foundation.open();
    };
    MDCDialog2.prototype.close = function(action) {
      if (action === void 0) {
        action = "";
      }
      this.foundation.close(action);
    };
    MDCDialog2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addBodyClass: function(className) {
          return document.body.classList.add(className);
        },
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        areButtonsStacked: function() {
          return areTopsMisaligned(_this.buttons);
        },
        clickDefaultButton: function() {
          if (_this.defaultButton && !_this.defaultButton.disabled) {
            _this.defaultButton.click();
          }
        },
        eventTargetMatches: function(target, selector) {
          return target ? matches(target, selector) : false;
        },
        getActionFromEvent: function(evt) {
          if (!evt.target) {
            return "";
          }
          var element2 = closest(evt.target, "[" + strings2.ACTION_ATTRIBUTE + "]");
          return element2 && element2.getAttribute(strings2.ACTION_ATTRIBUTE);
        },
        getInitialFocusEl: function() {
          return _this.getInitialFocusEl();
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        isContentScrollable: function() {
          return isScrollable(_this.content);
        },
        notifyClosed: function(action) {
          return _this.emit(strings2.CLOSED_EVENT, action ? { action } : {});
        },
        notifyClosing: function(action) {
          return _this.emit(strings2.CLOSING_EVENT, action ? { action } : {});
        },
        notifyOpened: function() {
          return _this.emit(strings2.OPENED_EVENT, {});
        },
        notifyOpening: function() {
          return _this.emit(strings2.OPENING_EVENT, {});
        },
        releaseFocus: function() {
          _this.focusTrap.releaseFocus();
        },
        removeBodyClass: function(className) {
          return document.body.classList.remove(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        reverseButtons: function() {
          _this.buttons.reverse();
          _this.buttons.forEach(function(button) {
            button.parentElement.appendChild(button);
          });
        },
        trapFocus: function() {
          _this.focusTrap.trapFocus();
        },
        registerContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.addEventListener(evt, handler);
          }
        },
        deregisterContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.removeEventListener(evt, handler);
          }
        },
        isScrollableContentAtTop: function() {
          return isScrollAtTop(_this.content);
        },
        isScrollableContentAtBottom: function() {
          return isScrollAtBottom(_this.content);
        },
        registerWindowEventHandler: function(evt, handler) {
          window.addEventListener(evt, handler);
        },
        deregisterWindowEventHandler: function(evt, handler) {
          window.removeEventListener(evt, handler);
        }
      };
      return new MDCDialogFoundation(adapter);
    };
    MDCDialog2.prototype.getInitialFocusEl = function() {
      return this.root.querySelector("[" + strings2.INITIAL_FOCUS_ATTRIBUTE + "]");
    };
    return MDCDialog2;
  }(MDCComponent)
);

// node_modules/@smui/dialog/dist/Dialog.svelte
var { document: document_1, window: window_1 } = globals;
var file = "node_modules/@smui/dialog/dist/Dialog.svelte";
var get_over_slot_changes = (dirty) => ({});
var get_over_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-dialog__surface-scrim");
      add_location(div, file, 48, 8, 1397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "transitionend",
          /*transitionend_handler*/
          ctx[32],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(48:6) {#if fullscreen}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t0;
  let div3;
  let div1;
  let div0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let t2;
  let div2;
  let div3_class_value;
  let useActions_action;
  let forwardEvents_action;
  let t3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let if_block = (
    /*fullscreen*/
    ctx[5] && create_if_block(ctx)
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*surface$class*/
          ctx[9]
        ]: true,
        "mdc-dialog__surface": true
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "surface$"
    )
  ];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*container$class*/
          ctx[8]
        ]: true,
        "mdc-dialog__container": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "container$"
    )
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  let div3_levels = [
    {
      class: div3_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-dialog": true,
        "mdc-dialog--stacked": !/*autoStackButtons*/
        ctx[4],
        "mdc-dialog--fullscreen": (
          /*fullscreen*/
          ctx[5]
        ),
        "mdc-dialog--sheet": (
          /*sheet*/
          ctx[6]
        ),
        "mdc-dialog--no-content-padding": (
          /*noContentPadding*/
          ctx[7]
        ),
        "smui-dialog--selection": (
          /*selection*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[12]
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    exclude(
      /*$$restProps*/
      ctx[19],
      ["container$", "surface$"]
    )
  ];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const over_slot_template = (
    /*#slots*/
    ctx[29].over
  );
  const over_slot = create_slot(
    over_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_over_slot_context
  );
  const block = {
    c: function create() {
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div2 = element("div");
      t3 = space();
      if (over_slot)
        over_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true
      });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (over_slot)
        over_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div0_data);
      add_location(div0, file, 37, 4, 1140);
      set_attributes(div1, div1_data);
      add_location(div1, file, 30, 2, 980);
      attr_dev(div2, "class", "mdc-dialog__scrim");
      add_location(div2, file, 56, 2, 1593);
      set_attributes(div3, div3_data);
      add_location(div3, file, 7, 0, 235);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      ctx[33](div3);
      insert_hydration_dev(target, t3, anchor);
      if (over_slot) {
        over_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "resize",
            /*resize_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "orientationchange",
            /*orientationchange_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            document_1.body,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            div3,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[13].call(null, div3)),
          listen_dev(
            div3,
            "SMUIDialog:opening",
            /*handleDialogOpening*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:opened",
            /*handleDialogOpened*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:closed",
            /*handleDialogClosed*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "click",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*fullscreen*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*surface$class*/
        512 && div0_class_value !== (div0_class_value = classMap({
          [
            /*surface$class*/
            ctx[9]
          ]: true,
          "mdc-dialog__surface": true
        }))) && { class: div0_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "surface$"
        )
      ]));
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*container$class*/
        256 && div1_class_value !== (div1_class_value = classMap({
          [
            /*container$class*/
            ctx[8]
          ]: true,
          "mdc-dialog__container": true
        }))) && { class: div1_class_value },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "container$"
        )
      ]));
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty[0] & /*className, autoStackButtons, fullscreen, sheet, noContentPadding, selection, internalClasses*/
        4348 && div3_class_value !== (div3_class_value = classMap({
          [
            /*className*/
            ctx[2]
          ]: true,
          "mdc-dialog": true,
          "mdc-dialog--stacked": !/*autoStackButtons*/
          ctx[4],
          "mdc-dialog--fullscreen": (
            /*fullscreen*/
            ctx[5]
          ),
          "mdc-dialog--sheet": (
            /*sheet*/
            ctx[6]
          ),
          "mdc-dialog--no-content-padding": (
            /*noContentPadding*/
            ctx[7]
          ),
          "smui-dialog--selection": (
            /*selection*/
            ctx[3]
          ),
          .../*internalClasses*/
          ctx[12]
        }))) && { class: div3_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && exclude(
          /*$$restProps*/
          ctx[19],
          ["container$", "surface$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[1]
        );
      if (over_slot) {
        if (over_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            over_slot,
            over_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              over_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              get_over_slot_changes
            ),
            get_over_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(over_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(over_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div3);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[33](null);
      if (detaching)
        detach_dev(t3);
      if (over_slot)
        over_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "open",
    "selection",
    "escapeKeyAction",
    "scrimClickAction",
    "autoStackButtons",
    "fullscreen",
    "sheet",
    "noContentPadding",
    "container$class",
    "surface$class",
    "isOpen",
    "setOpen",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $aboveFullscreenShown;
  let $actionButtonsReversed;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["default", "over"]);
  var _a;
  const { FocusTrap: FocusTrap2 } = focus_trap_exports;
  const { closest: closest2, matches: matches2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let { selection = false } = $$props;
  let { escapeKeyAction = "close" } = $$props;
  let { scrimClickAction = "close" } = $$props;
  let { autoStackButtons = true } = $$props;
  let { fullscreen = false } = $$props;
  let { sheet = false } = $$props;
  let { noContentPadding = false } = $$props;
  let { container$class = "" } = $$props;
  let { surface$class = "" } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let focusTrap;
  let actionButtonsReversed = writable(false);
  validate_store(actionButtonsReversed, "actionButtonsReversed");
  component_subscribe($$self, actionButtonsReversed, (value) => $$invalidate(37, $actionButtonsReversed = value));
  let aboveFullscreen = getContext("SMUI:dialog:aboveFullscreen");
  let aboveFullscreenShown = (_a = getContext("SMUI:dialog:aboveFullscreenShown")) !== null && _a !== void 0 ? _a : writable(false);
  validate_store(aboveFullscreenShown, "aboveFullscreenShown");
  component_subscribe($$self, aboveFullscreenShown, (value) => $$invalidate(27, $aboveFullscreenShown = value));
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let layoutListeners = [];
  let addLayoutListenerFn = (listener) => {
    layoutListeners.push(listener);
    return () => {
      const idx = layoutListeners.indexOf(listener);
      if (idx >= 0) {
        layoutListeners.splice(idx, 1);
      }
    };
  };
  setContext("SMUI:dialog:actions:reversed", actionButtonsReversed);
  setContext("SMUI:addLayoutListener", addLayoutListenerFn);
  setContext("SMUI:dialog:selection", selection);
  setContext("SMUI:dialog:aboveFullscreen", aboveFullscreen || fullscreen);
  setContext("SMUI:dialog:aboveFullscreenShown", aboveFullscreenShown);
  if (sheet) {
    setContext("SMUI:icon-button:context", "dialog:sheet");
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousAboveFullscreenShown = $aboveFullscreenShown;
  onMount(() => {
    var _a2;
    focusTrap = new FocusTrap2(
      element2,
      {
        initialFocusEl: (_a2 = getInitialFocusEl()) !== null && _a2 !== void 0 ? _a2 : void 0
      }
    );
    $$invalidate(10, instance = new MDCDialogFoundation({
      addBodyClass: (className2) => document.body.classList.add(className2),
      addClass,
      areButtonsStacked: () => util_exports.areTopsMisaligned(getButtonEls()),
      clickDefaultButton: () => {
        const defaultButton = getDefaultButtonEl();
        if (defaultButton) {
          defaultButton.click();
        }
      },
      eventTargetMatches: (target, selector) => target ? matches2(target, selector) : false,
      getActionFromEvent: (evt) => {
        if (!evt.target) {
          return "";
        }
        const element3 = closest2(evt.target, "[data-mdc-dialog-action]");
        return element3 && element3.getAttribute("data-mdc-dialog-action");
      },
      getInitialFocusEl,
      hasClass,
      isContentScrollable: () => util_exports.isScrollable(getContentEl()),
      notifyClosed: (action) => {
        $$invalidate(0, open = false);
        dispatch(getElement(), "SMUIDialog:closed", action ? { action } : {}, void 0, true);
      },
      notifyClosing: (action) => dispatch(getElement(), "SMUIDialog:closing", action ? { action } : {}, void 0, true),
      notifyOpened: () => dispatch(getElement(), "SMUIDialog:opened", {}, void 0, true),
      notifyOpening: () => dispatch(getElement(), "SMUIDialog:opening", {}, void 0, true),
      releaseFocus: () => focusTrap.releaseFocus(),
      removeBodyClass: (className2) => document.body.classList.remove(className2),
      removeClass,
      reverseButtons: () => {
        set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
      },
      trapFocus: () => focusTrap.trapFocus(),
      registerContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.addEventListener(evt, handler);
        }
      },
      deregisterContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.removeEventListener(evt, handler);
        }
      },
      isScrollableContentAtTop: () => {
        return util_exports.isScrollAtTop(getContentEl());
      },
      isScrollableContentAtBottom: () => {
        return util_exports.isScrollAtBottom(getContentEl());
      },
      registerWindowEventHandler: (evt, handler) => {
        window.addEventListener(evt, handler);
      },
      deregisterWindowEventHandler: (evt, handler) => {
        window.removeEventListener(evt, handler);
      }
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function getButtonEls() {
    return [].slice.call(element2.querySelectorAll(".mdc-dialog__button"));
  }
  function getDefaultButtonEl() {
    return element2.querySelector("[data-mdc-dialog-button-default");
  }
  function getContentEl() {
    return element2.querySelector(".mdc-dialog__content");
  }
  function getInitialFocusEl() {
    return element2.querySelector("[data-mdc-dialog-initial-focus]");
  }
  function handleDialogOpening() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = true, $aboveFullscreenShown);
    }
    requestAnimationFrame(() => {
      layoutListeners.forEach((listener) => listener());
    });
  }
  function handleDialogOpened() {
    layoutListeners.forEach((listener) => listener());
  }
  function handleDialogClosed() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = false, $aboveFullscreenShown);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function layout() {
    return instance.layout();
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => open && instance && instance.layout();
  const orientationchange_handler = () => open && instance && instance.layout();
  const transitionend_handler = () => instance && instance.handleSurfaceScrimTransitionEnd();
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(11, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$new_props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$new_props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$new_props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$new_props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$new_props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$new_props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$new_props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$new_props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCDialogFoundation,
    util: util_exports,
    domFocusTrap: focus_trap_exports,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    FocusTrap: FocusTrap2,
    closest: closest2,
    matches: matches2,
    forwardEvents,
    use,
    className,
    open,
    selection,
    escapeKeyAction,
    scrimClickAction,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    element: element2,
    instance,
    internalClasses,
    focusTrap,
    actionButtonsReversed,
    aboveFullscreen,
    aboveFullscreenShown,
    addLayoutListener,
    removeLayoutListener,
    layoutListeners,
    addLayoutListenerFn,
    previousAboveFullscreenShown,
    hasClass,
    addClass,
    removeClass,
    getButtonEls,
    getDefaultButtonEl,
    getContentEl,
    getInitialFocusEl,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    isOpen,
    setOpen,
    layout,
    getElement,
    $aboveFullscreenShown,
    $actionButtonsReversed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("element" in $$props)
      $$invalidate(11, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(10, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("focusTrap" in $$props)
      focusTrap = $$new_props.focusTrap;
    if ("actionButtonsReversed" in $$props)
      $$invalidate(14, actionButtonsReversed = $$new_props.actionButtonsReversed);
    if ("aboveFullscreen" in $$props)
      $$invalidate(41, aboveFullscreen = $$new_props.aboveFullscreen);
    if ("aboveFullscreenShown" in $$props)
      $$invalidate(15, aboveFullscreenShown = $$new_props.aboveFullscreenShown);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("layoutListeners" in $$props)
      layoutListeners = $$new_props.layoutListeners;
    if ("addLayoutListenerFn" in $$props)
      addLayoutListenerFn = $$new_props.addLayoutListenerFn;
    if ("previousAboveFullscreenShown" in $$props)
      $$invalidate(26, previousAboveFullscreenShown = $$new_props.previousAboveFullscreenShown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, escapeKeyAction*/
    1049600) {
      $:
        if (instance && instance.getEscapeKeyAction() !== escapeKeyAction) {
          instance.setEscapeKeyAction(escapeKeyAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, scrimClickAction*/
    2098176) {
      $:
        if (instance && instance.getScrimClickAction() !== scrimClickAction) {
          instance.setScrimClickAction(scrimClickAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, autoStackButtons*/
    1040) {
      $:
        if (instance && instance.getAutoStackButtons() !== autoStackButtons) {
          instance.setAutoStackButtons(autoStackButtons);
        }
    }
    if ($$self.$$.dirty[0] & /*autoStackButtons*/
    16) {
      $:
        if (!autoStackButtons) {
          set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, open*/
    1025) {
      $:
        if (instance && instance.isOpen() !== open) {
          if (open) {
            instance.open({
              isAboveFullscreenDialog: !!aboveFullscreen
            });
          } else {
            instance.close();
          }
        }
    }
    if ($$self.$$.dirty[0] & /*fullscreen, instance, previousAboveFullscreenShown, $aboveFullscreenShown*/
    201327648) {
      $:
        if (fullscreen && instance && previousAboveFullscreenShown !== $aboveFullscreenShown) {
          $$invalidate(26, previousAboveFullscreenShown = $aboveFullscreenShown);
          if ($aboveFullscreenShown) {
            instance.showSurfaceScrim();
          } else {
            instance.hideSurfaceScrim();
          }
        }
    }
  };
  return [
    open,
    use,
    className,
    selection,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    instance,
    element2,
    internalClasses,
    forwardEvents,
    actionButtonsReversed,
    aboveFullscreenShown,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    $$restProps,
    escapeKeyAction,
    scrimClickAction,
    isOpen,
    setOpen,
    layout,
    getElement,
    previousAboveFullscreenShown,
    $aboveFullscreenShown,
    $$scope,
    slots,
    resize_handler,
    orientationchange_handler,
    transitionend_handler,
    div3_binding
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        open: 0,
        selection: 3,
        escapeKeyAction: 20,
        scrimClickAction: 21,
        autoStackButtons: 4,
        fullscreen: 5,
        sheet: 6,
        noContentPadding: 7,
        container$class: 8,
        surface$class: 9,
        isOpen: 22,
        setOpen: 23,
        layout: 24,
        getElement: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeKeyAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeKeyAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrimClickAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrimClickAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoStackButtons() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoStackButtons(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sheet() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sheet(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noContentPadding() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noContentPadding(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[22];
  }
  set isOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[23];
  }
  set setOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[24];
  }
  set layout(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[25];
  }
  set getElement(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// node_modules/@smui/dialog/dist/Header.js
var Header_default = classAdderBuilder({
  class: "mdc-dialog__header",
  tag: "div",
  contexts: {
    "SMUI:icon-button:context": "dialog:header"
  }
});

// node_modules/@smui/dialog/dist/Title.js
var Title_default = classAdderBuilder({
  class: "mdc-dialog__title",
  tag: "h2"
});

// node_modules/@smui/dialog/dist/Content.js
var Content_default = classAdderBuilder({
  class: "mdc-dialog__content",
  tag: "div"
});

// node_modules/@smui/dialog/dist/Actions.js
var Actions_default = classAdderBuilder({
  class: "mdc-dialog__actions",
  tag: "div",
  classMap: {
    "smui-dialog__actions--reversed": "SMUI:dialog:actions:reversed"
  },
  contexts: {
    "SMUI:button:context": "dialog:action"
  }
});

// node_modules/@smui/dialog/dist/InitialFocus.js
function InitialFocus(node) {
  node.setAttribute("data-mdc-dialog-initial-focus", "");
  return {
    destroy() {
      node.removeAttribute("data-mdc-dialog-initial-focus");
    }
  };
}

// node_modules/@smui/dialog/dist/index.js
var dist_default = Dialog_default;
export {
  Actions_default as Actions,
  Content_default as Content,
  Header_default as Header,
  InitialFocus,
  Title_default as Title,
  dist_default as default
};
/*! Bundled license information:

@material/dialog/util.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/foundation.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/component.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_dialog.js.map
