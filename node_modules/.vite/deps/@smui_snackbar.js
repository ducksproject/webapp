import {
  classAdderBuilder
} from "./chunk-O74RPVUT.js";
import {
  closest,
  ponyfill_exports
} from "./chunk-LT7LFURX.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends
} from "./chunk-2FLFGTFT.js";
import {
  CommonLabel_default
} from "./chunk-PYKRMECV.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-MPIJALNF.js";
import "./chunk-ADM3CLVU.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  binding_callbacks,
  children,
  claim_element,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-3PEI35UK.js";
import {
  __export
} from "./chunk-JC4IRQUL.js";

// node_modules/@material/snackbar/util.js
var util_exports = {};
__export(util_exports, {
  announce: () => announce
});

// node_modules/@material/snackbar/constants.js
var cssClasses = {
  CLOSING: "mdc-snackbar--closing",
  OPEN: "mdc-snackbar--open",
  OPENING: "mdc-snackbar--opening"
};
var strings = {
  ACTION_SELECTOR: ".mdc-snackbar__action",
  ARIA_LIVE_LABEL_TEXT_ATTR: "data-mdc-snackbar-label-text",
  CLOSED_EVENT: "MDCSnackbar:closed",
  CLOSING_EVENT: "MDCSnackbar:closing",
  DISMISS_SELECTOR: ".mdc-snackbar__dismiss",
  LABEL_SELECTOR: ".mdc-snackbar__label",
  OPENED_EVENT: "MDCSnackbar:opened",
  OPENING_EVENT: "MDCSnackbar:opening",
  REASON_ACTION: "action",
  REASON_DISMISS: "dismiss",
  SURFACE_SELECTOR: ".mdc-snackbar__surface"
};
var numbers = {
  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5e3,
  INDETERMINATE: -1,
  MAX_AUTO_DISMISS_TIMEOUT_MS: 1e4,
  MIN_AUTO_DISMISS_TIMEOUT_MS: 4e3,
  // These variables need to be kept in sync with the values in _variables.scss.
  SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
  SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
  /**
   * Number of milliseconds to wait between temporarily clearing the label text
   * in the DOM and subsequently restoring it. This is necessary to force IE 11
   * to pick up the `aria-live` content change and announce it to the user.
   */
  ARIA_LIVE_DELAY_MS: 1e3
};

// node_modules/@material/snackbar/util.js
var ARIA_LIVE_DELAY_MS = numbers.ARIA_LIVE_DELAY_MS;
var ARIA_LIVE_LABEL_TEXT_ATTR = strings.ARIA_LIVE_LABEL_TEXT_ATTR;
function announce(ariaEl, labelEl) {
  if (labelEl === void 0) {
    labelEl = ariaEl;
  }
  var priority = ariaEl.getAttribute("aria-live");
  var labelText = labelEl.textContent.trim();
  if (!labelText || !priority) {
    return;
  }
  ariaEl.setAttribute("aria-live", "off");
  labelEl.textContent = "";
  var span = document.createElement("span");
  span.setAttribute("style", "display: inline-block; width: 0; height: 1px;");
  span.textContent = " ";
  labelEl.appendChild(span);
  labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
  setTimeout(function() {
    ariaEl.setAttribute("aria-live", priority);
    labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);
    labelEl.textContent = labelText;
  }, ARIA_LIVE_DELAY_MS);
}

// node_modules/@material/snackbar/foundation.js
var OPENING = cssClasses.OPENING;
var OPEN = cssClasses.OPEN;
var CLOSING = cssClasses.CLOSING;
var REASON_ACTION = strings.REASON_ACTION;
var REASON_DISMISS = strings.REASON_DISMISS;
var MDCSnackbarFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSnackbarFoundation2, _super);
    function MDCSnackbarFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCSnackbarFoundation2.defaultAdapter), adapter)) || this;
      _this.opened = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      _this.autoDismissTimer = 0;
      _this.autoDismissTimeoutMs = numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
      _this.closeOnEscape = true;
      return _this;
    }
    Object.defineProperty(MDCSnackbarFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbarFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          announce: function() {
            return void 0;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSnackbarFoundation2.prototype.destroy = function() {
      this.clearAutoDismissTimer();
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = 0;
      this.adapter.removeClass(OPENING);
      this.adapter.removeClass(OPEN);
      this.adapter.removeClass(CLOSING);
    };
    MDCSnackbarFoundation2.prototype.open = function() {
      var _this = this;
      this.clearAutoDismissTimer();
      this.opened = true;
      this.adapter.notifyOpening();
      this.adapter.removeClass(CLOSING);
      this.adapter.addClass(OPENING);
      this.adapter.announce();
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(OPEN);
        _this.animationTimer = setTimeout(function() {
          var timeoutMs = _this.getTimeoutMs();
          _this.handleAnimationTimerEnd();
          _this.adapter.notifyOpened();
          if (timeoutMs !== numbers.INDETERMINATE) {
            _this.autoDismissTimer = setTimeout(function() {
              _this.close(REASON_DISMISS);
            }, timeoutMs);
          }
        }, numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCSnackbarFoundation2.prototype.close = function(reason) {
      var _this = this;
      if (reason === void 0) {
        reason = "";
      }
      if (!this.opened) {
        return;
      }
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      this.clearAutoDismissTimer();
      this.opened = false;
      this.adapter.notifyClosing(reason);
      this.adapter.addClass(cssClasses.CLOSING);
      this.adapter.removeClass(cssClasses.OPEN);
      this.adapter.removeClass(cssClasses.OPENING);
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(reason);
      }, numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
    };
    MDCSnackbarFoundation2.prototype.isOpen = function() {
      return this.opened;
    };
    MDCSnackbarFoundation2.prototype.getTimeoutMs = function() {
      return this.autoDismissTimeoutMs;
    };
    MDCSnackbarFoundation2.prototype.setTimeoutMs = function(timeoutMs) {
      var minValue = numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
      var maxValue = numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;
      var indeterminateValue = numbers.INDETERMINATE;
      if (timeoutMs === numbers.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
        this.autoDismissTimeoutMs = timeoutMs;
      } else {
        throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "–" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
      }
    };
    MDCSnackbarFoundation2.prototype.getCloseOnEscape = function() {
      return this.closeOnEscape;
    };
    MDCSnackbarFoundation2.prototype.setCloseOnEscape = function(closeOnEscape) {
      this.closeOnEscape = closeOnEscape;
    };
    MDCSnackbarFoundation2.prototype.handleKeyDown = function(evt) {
      var isEscapeKey = evt.key === "Escape" || evt.keyCode === 27;
      if (isEscapeKey && this.getCloseOnEscape()) {
        this.close(REASON_DISMISS);
      }
    };
    MDCSnackbarFoundation2.prototype.handleActionButtonClick = function(_evt) {
      this.close(REASON_ACTION);
    };
    MDCSnackbarFoundation2.prototype.handleActionIconClick = function(_evt) {
      this.close(REASON_DISMISS);
    };
    MDCSnackbarFoundation2.prototype.clearAutoDismissTimer = function() {
      clearTimeout(this.autoDismissTimer);
      this.autoDismissTimer = 0;
    };
    MDCSnackbarFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(cssClasses.OPENING);
      this.adapter.removeClass(cssClasses.CLOSING);
    };
    MDCSnackbarFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    return MDCSnackbarFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/snackbar/component.js
var SURFACE_SELECTOR = strings.SURFACE_SELECTOR;
var LABEL_SELECTOR = strings.LABEL_SELECTOR;
var ACTION_SELECTOR = strings.ACTION_SELECTOR;
var DISMISS_SELECTOR = strings.DISMISS_SELECTOR;
var OPENING_EVENT = strings.OPENING_EVENT;
var OPENED_EVENT = strings.OPENED_EVENT;
var CLOSING_EVENT = strings.CLOSING_EVENT;
var CLOSED_EVENT = strings.CLOSED_EVENT;
var MDCSnackbar = (
  /** @class */
  function(_super) {
    __extends(MDCSnackbar2, _super);
    function MDCSnackbar2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSnackbar2.attachTo = function(root) {
      return new MDCSnackbar2(root);
    };
    MDCSnackbar2.prototype.initialize = function(announcerFactory) {
      if (announcerFactory === void 0) {
        announcerFactory = function() {
          return announce;
        };
      }
      this.announce = announcerFactory();
    };
    MDCSnackbar2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.surfaceEl = this.root.querySelector(SURFACE_SELECTOR);
      this.labelEl = this.root.querySelector(LABEL_SELECTOR);
      this.actionEl = this.root.querySelector(ACTION_SELECTOR);
      this.handleKeyDown = function(evt) {
        _this.foundation.handleKeyDown(evt);
      };
      this.handleSurfaceClick = function(evt) {
        var target = evt.target;
        if (_this.isActionButton(target)) {
          _this.foundation.handleActionButtonClick(evt);
        } else if (_this.isActionIcon(target)) {
          _this.foundation.handleActionIconClick(evt);
        }
      };
      this.registerKeyDownHandler(this.handleKeyDown);
      this.registerSurfaceClickHandler(this.handleSurfaceClick);
    };
    MDCSnackbar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.deregisterKeyDownHandler(this.handleKeyDown);
      this.deregisterSurfaceClickHandler(this.handleSurfaceClick);
    };
    MDCSnackbar2.prototype.open = function() {
      this.foundation.open();
    };
    MDCSnackbar2.prototype.close = function(reason) {
      if (reason === void 0) {
        reason = "";
      }
      this.foundation.close(reason);
    };
    MDCSnackbar2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        announce: function() {
          _this.announce(_this.labelEl);
        },
        notifyClosed: function(reason) {
          return _this.emit(CLOSED_EVENT, reason ? { reason } : {});
        },
        notifyClosing: function(reason) {
          return _this.emit(CLOSING_EVENT, reason ? { reason } : {});
        },
        notifyOpened: function() {
          return _this.emit(OPENED_EVENT, {});
        },
        notifyOpening: function() {
          return _this.emit(OPENING_EVENT, {});
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        }
      };
      return new MDCSnackbarFoundation(adapter);
    };
    Object.defineProperty(MDCSnackbar2.prototype, "timeoutMs", {
      get: function() {
        return this.foundation.getTimeoutMs();
      },
      set: function(timeoutMs) {
        this.foundation.setTimeoutMs(timeoutMs);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbar2.prototype, "closeOnEscape", {
      get: function() {
        return this.foundation.getCloseOnEscape();
      },
      set: function(closeOnEscape) {
        this.foundation.setCloseOnEscape(closeOnEscape);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbar2.prototype, "isOpen", {
      get: function() {
        return this.foundation.isOpen();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbar2.prototype, "labelText", {
      get: function() {
        return this.labelEl.textContent;
      },
      set: function(labelText) {
        this.labelEl.textContent = labelText;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSnackbar2.prototype, "actionButtonText", {
      get: function() {
        return this.actionEl.textContent;
      },
      set: function(actionButtonText) {
        this.actionEl.textContent = actionButtonText;
      },
      enumerable: false,
      configurable: true
    });
    MDCSnackbar2.prototype.registerKeyDownHandler = function(handler) {
      this.listen("keydown", handler);
    };
    MDCSnackbar2.prototype.deregisterKeyDownHandler = function(handler) {
      this.unlisten("keydown", handler);
    };
    MDCSnackbar2.prototype.registerSurfaceClickHandler = function(handler) {
      this.surfaceEl.addEventListener("click", handler);
    };
    MDCSnackbar2.prototype.deregisterSurfaceClickHandler = function(handler) {
      this.surfaceEl.removeEventListener("click", handler);
    };
    MDCSnackbar2.prototype.isActionButton = function(target) {
      return Boolean(closest(target, ACTION_SELECTOR));
    };
    MDCSnackbar2.prototype.isActionIcon = function(target) {
      return Boolean(closest(target, DISMISS_SELECTOR));
    };
    return MDCSnackbar2;
  }(MDCComponent)
);

// node_modules/@smui/snackbar/dist/Snackbar.svelte
var file = "node_modules/@smui/snackbar/dist/Snackbar.svelte";
function create_fragment(ctx) {
  let aside;
  let div;
  let div_class_value;
  let useActions_action;
  let aside_class_value;
  let useActions_action_1;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*surface$class*/
          ctx[4]
        ]: true,
        "mdc-snackbar__surface": true
      })
    },
    { role: "status" },
    { "aria-relevant": "additions" },
    prefixFilter(
      /*$$restProps*/
      ctx[12],
      "surface$"
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let aside_levels = [
    {
      class: aside_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-snackbar": true,
        "mdc-snackbar--stacked": (
          /*variant*/
          ctx[2] === "stacked"
        ),
        "mdc-snackbar--leading": (
          /*leading*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[8]
      })
    },
    exclude(
      /*$$restProps*/
      ctx[12],
      ["surface$"]
    )
  ];
  let aside_data = {};
  for (let i = 0; i < aside_levels.length; i += 1) {
    aside_data = assign(aside_data, aside_levels[i]);
  }
  const block = {
    c: function create() {
      aside = element("aside");
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      div = claim_element(aside_nodes, "DIV", {
        class: true,
        role: true,
        "aria-relevant": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 15, 2, 412);
      set_attributes(aside, aside_data);
      add_location(aside, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[26](aside);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*surface$use*/
            ctx[5]
          )),
          listen_dev(
            div,
            "click",
            /*handleSurfaceClick*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            aside,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[9].call(null, aside)),
          listen_dev(
            aside,
            "SMUISnackbar:closed",
            /*handleClosed*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            aside,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[6] && /*instance*/
                ctx[6].handleKeyDown.bind(
                  /*instance*/
                  ctx[6]
                )
              ))
                /*instance*/
                (ctx[6] && /*instance*/
                ctx[6].handleKeyDown.bind(
                  /*instance*/
                  ctx[6]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*surface$class*/
        16 && div_class_value !== (div_class_value = classMap({
          [
            /*surface$class*/
            ctx[4]
          ]: true,
          "mdc-snackbar__surface": true
        }))) && { class: div_class_value },
        { role: "status" },
        { "aria-relevant": "additions" },
        dirty[0] & /*$$restProps*/
        4096 && prefixFilter(
          /*$$restProps*/
          ctx[12],
          "surface$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*surface$use*/
      32)
        useActions_action.update.call(
          null,
          /*surface$use*/
          ctx[5]
        );
      set_attributes(aside, aside_data = get_spread_update(aside_levels, [
        (!current || dirty[0] & /*className, variant, leading, internalClasses*/
        270 && aside_class_value !== (aside_class_value = classMap({
          [
            /*className*/
            ctx[1]
          ]: true,
          "mdc-snackbar": true,
          "mdc-snackbar--stacked": (
            /*variant*/
            ctx[2] === "stacked"
          ),
          "mdc-snackbar--leading": (
            /*leading*/
            ctx[3]
          ),
          .../*internalClasses*/
          ctx[8]
        }))) && { class: aside_class_value },
        dirty[0] & /*$$restProps*/
        4096 && exclude(
          /*$$restProps*/
          ctx[12],
          ["surface$"]
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*use*/
      1)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (default_slot)
        default_slot.d(detaching);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var waiting = Promise.resolve();
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "variant",
    "leading",
    "timeoutMs",
    "closeOnEscape",
    "labelText",
    "actionButtonText",
    "surface$class",
    "surface$use",
    "open",
    "forceOpen",
    "close",
    "isOpen",
    "getLabelElement",
    "getActionButtonElement",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Snackbar", slots, ["default"]);
  const { closest: closest2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = "" } = $$props;
  let { leading = false } = $$props;
  let { timeoutMs = 5e3 } = $$props;
  let { closeOnEscape = true } = $$props;
  let { labelText = uninitializedValue } = $$props;
  let { actionButtonText = uninitializedValue } = $$props;
  let { surface$class = "" } = $$props;
  let { surface$use = [] } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let closeResolve;
  let closePromise = new Promise((resolve) => closeResolve = resolve);
  setContext("SMUI:label:context", "snackbar");
  onMount(() => {
    $$invalidate(6, instance = new MDCSnackbarFoundation({
      addClass,
      announce: () => util_exports.announce(getLabelElement()),
      notifyClosed: (reason) => dispatch(getElement(), "SMUISnackbar:closed", reason ? { reason } : {}, void 0, true),
      notifyClosing: (reason) => dispatch(getElement(), "SMUISnackbar:closing", reason ? { reason } : {}, void 0, true),
      notifyOpened: () => dispatch(getElement(), "SMUISnackbar:opened", void 0, void 0, true),
      notifyOpening: () => dispatch(getElement(), "SMUISnackbar:opening", void 0, void 0, true),
      removeClass
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function handleSurfaceClick(event) {
    const target = event.target;
    if (instance) {
      if (closest2(target, ".mdc-snackbar__action")) {
        instance.handleActionButtonClick(event);
      } else if (closest2(target, ".mdc-snackbar__dismiss")) {
        instance.handleActionIconClick(event);
      }
    }
  }
  function handleClosed() {
    closeResolve();
    closePromise = new Promise((resolve) => closeResolve = resolve);
  }
  function open() {
    waiting = waiting.then(() => {
      instance.open();
      return closePromise;
    });
  }
  function forceOpen() {
    return instance.open();
  }
  function close(reason) {
    return instance.close(reason);
  }
  function isOpen() {
    return instance.isOpen();
  }
  function getLabelElement() {
    var _a;
    return (_a = getElement().querySelector(".mdc-snackbar__label")) !== null && _a !== void 0 ? _a : document.createElement("div");
  }
  function getActionButtonElement() {
    var _a;
    return (_a = getElement().querySelector(".mdc-snackbar__action")) !== null && _a !== void 0 ? _a : document.createElement("button");
  }
  function getElement() {
    return element2;
  }
  function aside_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("variant" in $$new_props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("leading" in $$new_props)
      $$invalidate(3, leading = $$new_props.leading);
    if ("timeoutMs" in $$new_props)
      $$invalidate(13, timeoutMs = $$new_props.timeoutMs);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(14, closeOnEscape = $$new_props.closeOnEscape);
    if ("labelText" in $$new_props)
      $$invalidate(15, labelText = $$new_props.labelText);
    if ("actionButtonText" in $$new_props)
      $$invalidate(16, actionButtonText = $$new_props.actionButtonText);
    if ("surface$class" in $$new_props)
      $$invalidate(4, surface$class = $$new_props.surface$class);
    if ("surface$use" in $$new_props)
      $$invalidate(5, surface$use = $$new_props.surface$use);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    waiting,
    MDCSnackbarFoundation,
    util: util_exports,
    ponyfill: ponyfill_exports,
    onMount,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    closest: closest2,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    variant,
    leading,
    timeoutMs,
    closeOnEscape,
    labelText,
    actionButtonText,
    surface$class,
    surface$use,
    element: element2,
    instance,
    internalClasses,
    closeResolve,
    closePromise,
    addClass,
    removeClass,
    handleSurfaceClick,
    handleClosed,
    open,
    forceOpen,
    close,
    isOpen,
    getLabelElement,
    getActionButtonElement,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("variant" in $$props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("leading" in $$props)
      $$invalidate(3, leading = $$new_props.leading);
    if ("timeoutMs" in $$props)
      $$invalidate(13, timeoutMs = $$new_props.timeoutMs);
    if ("closeOnEscape" in $$props)
      $$invalidate(14, closeOnEscape = $$new_props.closeOnEscape);
    if ("labelText" in $$props)
      $$invalidate(15, labelText = $$new_props.labelText);
    if ("actionButtonText" in $$props)
      $$invalidate(16, actionButtonText = $$new_props.actionButtonText);
    if ("surface$class" in $$props)
      $$invalidate(4, surface$class = $$new_props.surface$class);
    if ("surface$use" in $$props)
      $$invalidate(5, surface$use = $$new_props.surface$use);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(6, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("closeResolve" in $$props)
      closeResolve = $$new_props.closeResolve;
    if ("closePromise" in $$props)
      closePromise = $$new_props.closePromise;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, timeoutMs*/
    8256) {
      $:
        if (instance && instance.getTimeoutMs() !== timeoutMs) {
          instance.setTimeoutMs(timeoutMs);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, closeOnEscape*/
    16448) {
      $:
        if (instance && instance.getCloseOnEscape() !== closeOnEscape) {
          instance.setCloseOnEscape(closeOnEscape);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, labelText*/
    32832) {
      $:
        if (instance && !isUninitializedValue(labelText) && getLabelElement().textContent !== labelText) {
          getLabelElement().textContent = labelText;
        }
    }
    if ($$self.$$.dirty[0] & /*instance, actionButtonText*/
    65600) {
      $:
        if (instance && !isUninitializedValue(actionButtonText) && getActionButtonElement().textContent !== actionButtonText) {
          getActionButtonElement().textContent = actionButtonText;
        }
    }
  };
  return [
    use,
    className,
    variant,
    leading,
    surface$class,
    surface$use,
    instance,
    element2,
    internalClasses,
    forwardEvents,
    handleSurfaceClick,
    handleClosed,
    $$restProps,
    timeoutMs,
    closeOnEscape,
    labelText,
    actionButtonText,
    open,
    forceOpen,
    close,
    isOpen,
    getLabelElement,
    getActionButtonElement,
    getElement,
    $$scope,
    slots,
    aside_binding
  ];
}
var Snackbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        variant: 2,
        leading: 3,
        timeoutMs: 13,
        closeOnEscape: 14,
        labelText: 15,
        actionButtonText: 16,
        surface$class: 4,
        surface$use: 5,
        open: 17,
        forceOpen: 18,
        close: 19,
        isOpen: 20,
        getLabelElement: 21,
        getActionButtonElement: 22,
        getElement: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Snackbar",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leading() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leading(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeoutMs() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeoutMs(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionButtonText() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionButtonText(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$class() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$class(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$use() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$use(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    return this.$$.ctx[17];
  }
  set open(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceOpen() {
    return this.$$.ctx[18];
  }
  set forceOpen(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    return this.$$.ctx[19];
  }
  set close(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[20];
  }
  set isOpen(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getLabelElement() {
    return this.$$.ctx[21];
  }
  set getLabelElement(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getActionButtonElement() {
    return this.$$.ctx[22];
  }
  set getActionButtonElement(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[23];
  }
  set getElement(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Snackbar_default = Snackbar;

// node_modules/@smui/snackbar/dist/Actions.js
var Actions_default = classAdderBuilder({
  class: "mdc-snackbar__actions",
  tag: "div",
  props: { "aria-atomic": "true" },
  contexts: {
    "SMUI:button:context": "snackbar:actions",
    "SMUI:icon-button:context": "snackbar:actions",
    "SMUI:label:context": void 0
  }
});

// node_modules/@smui/snackbar/dist/index.js
var dist_default = Snackbar_default;
export {
  Actions_default as Actions,
  CommonLabel_default as Label,
  dist_default as default
};
/*! Bundled license information:

@material/snackbar/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/util.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/snackbar/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_snackbar.js.map
